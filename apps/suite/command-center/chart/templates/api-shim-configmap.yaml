apiVersion: v1
kind: ConfigMap
metadata:
  name: suite-command-center-api-shim
  namespace: suite
data:
  server.py: |
    # Minimal K8s-backed API shim (stdlib only)
    # Serves: /healthz, /summary, /nodes, /pods, /workloads, /events
    # Also supports: /v1/* and /cluster/* aliases (because Traefik strips /api)

    import json
    import os
    import ssl
    import time
    import urllib.request
    import urllib.error
    from http.server import BaseHTTPRequestHandler, HTTPServer
    from urllib.parse import urlparse, parse_qs

    K8S_BASE = os.environ.get("K8S_BASE", "https://kubernetes.default.svc")
    TOKEN_PATH = os.environ.get("K8S_TOKEN_PATH", "/var/run/secrets/kubernetes.io/serviceaccount/token")
    CA_PATH = os.environ.get("K8S_CA_PATH", "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt")
    PORT = int(os.environ.get("PORT", "8000"))
    NAME = os.environ.get("APP_NAME", "suite-command-center-api-shim")

    def _read_file(path: str) -> str:
      with open(path, "r", encoding="utf-8") as f:
        return f.read().strip()

    def k8s_get_json(path_with_query: str, timeout: int = 10):
      token = _read_file(TOKEN_PATH)
      ctx = ssl.create_default_context(cafile=CA_PATH)

      url = K8S_BASE.rstrip("/") + path_with_query
      req = urllib.request.Request(
        url,
        headers={
          "Authorization": f"Bearer {token}",
          "Accept": "application/json",
          "User-Agent": NAME,
        },
        method="GET",
      )

      try:
        with urllib.request.urlopen(req, context=ctx, timeout=timeout) as resp:
          body = resp.read().decode("utf-8", errors="replace")
          return resp.status, json.loads(body)
      except urllib.error.HTTPError as e:
        body = e.read().decode("utf-8", errors="replace") if hasattr(e, "read") else ""
        try:
          return e.code, json.loads(body) if body else {"error": str(e)}
        except Exception:
          return e.code, {"error": str(e), "body": body[:2000]}
      except Exception as e:
        return 500, {"error": str(e)}

    def summarize_nodes(nodes_obj):
      items = nodes_obj.get("items", [])
      total = len(items)
      ready = 0
      for n in items:
        conds = (n.get("status", {}) or {}).get("conditions", []) or []
        for c in conds:
          if c.get("type") == "Ready" and c.get("status") == "True":
            ready += 1
            break
      return {"total": total, "ready": ready}

    def summarize_pods(pods_obj):
      items = pods_obj.get("items", [])
      total = len(items)
      running = 0
      for p in items:
        phase = (p.get("status", {}) or {}).get("phase")
        if phase == "Running":
          running += 1
      return {"total": total, "running": running}

    def summarize_workloads(dep_obj, ds_obj, sts_obj):
      return {
        "deployments": len((dep_obj.get("items", []) or [])),
        "daemonsets": len((ds_obj.get("items", []) or [])),
        "statefulsets": len((sts_obj.get("items", []) or [])),
      }

    class Handler(BaseHTTPRequestHandler):
      server_version = "suite-command-center-api-shim/0.1"

      def _send(self, code: int, payload: dict):
        b = json.dumps(payload).encode("utf-8")
        self.send_response(code)
        self.send_header("Content-Type", "application/json; charset=utf-8")
        self.send_header("Content-Length", str(len(b)))
        self.end_headers()
        self.wfile.write(b)

      def log_message(self, fmt, *args):
        # Show requests in kubectl logs (handy for debugging)
        print("%s - - [%s] %s" % (self.client_address[0], self.log_date_time_string(), fmt % args))

      def do_GET(self):
        u = urlparse(self.path)
        path = u.path
        q = parse_qs(u.query)

        # Normalize aliases (Traefik strips /api, so UI may hit /v1/*)
        def is_any(pats):
          return path in pats

        if is_any(("/healthz", "/api/healthz")):
          return self._send(200, {"ok": True, "name": NAME, "ts": int(time.time())})

        # /summary (+ aliases)
        if is_any(("/summary", "/v1/summary", "/cluster/summary")):
          n_code, nodes = k8s_get_json("/api/v1/nodes")
          p_code, pods  = k8s_get_json("/api/v1/pods")
          d_code, deps  = k8s_get_json("/apis/apps/v1/deployments")
          ds_code, dss  = k8s_get_json("/apis/apps/v1/daemonsets")
          s_code, stss  = k8s_get_json("/apis/apps/v1/statefulsets")

          if max(n_code, p_code, d_code, ds_code, s_code) >= 400:
            return self._send(502, {
              "error": "upstream k8s API error",
              "nodes": {"code": n_code},
              "pods": {"code": p_code},
              "deployments": {"code": d_code},
              "daemonsets": {"code": ds_code},
              "statefulsets": {"code": s_code},
            })

          return self._send(200, {
            "nodes": summarize_nodes(nodes),
            "pods": summarize_pods(pods),
            "workloads": summarize_workloads(deps, dss, stss),
            "ts": int(time.time()),
          })

        # /nodes (+ aliases) -> raw K8s list (UI can count items)
        if is_any(("/nodes", "/v1/nodes", "/cluster/nodes")):
          code, obj = k8s_get_json("/api/v1/nodes")
          return self._send(code, obj)

        # /pods (+ aliases) -> namespace optional
        if is_any(("/pods", "/v1/pods", "/cluster/pods")):
          ns = (q.get("namespace") or [None])[0]
          if ns:
            code, obj = k8s_get_json(f"/api/v1/namespaces/{ns}/pods")
          else:
            code, obj = k8s_get_json("/api/v1/pods")
          return self._send(code, obj)

        # /events (+ aliases)
        if is_any(("/events", "/v1/events", "/cluster/events")):
          code, obj = k8s_get_json("/api/v1/events?limit=200")
          return self._send(code, obj)

        # /workloads (+ aliases) -> combined
        if is_any(("/workloads", "/v1/workloads", "/cluster/workloads")):
          d_code, deps  = k8s_get_json("/apis/apps/v1/deployments")
          ds_code, dss  = k8s_get_json("/apis/apps/v1/daemonsets")
          s_code, stss  = k8s_get_json("/apis/apps/v1/statefulsets")
          code = max(d_code, ds_code, s_code)
          return self._send(code if code >= 400 else 200, {
            "deployments": deps,
            "daemonsets": dss,
            "statefulsets": stss,
            "ts": int(time.time()),
          })

        # Default: show supported routes (helps you spot what UI is calling)
        return self._send(404, {
          "error": "not found",
          "path": path,
          "hint": "supported: /healthz /summary /nodes /pods /workloads /events (+ /v1/* + /cluster/* aliases)"
        })

    def main():
      print(f"{NAME}: starting on 0.0.0.0:{PORT}, k8s={K8S_BASE}")
      HTTPServer(("0.0.0.0", PORT), Handler).serve_forever()

    if __name__ == "__main__":
      main()
